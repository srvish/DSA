Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

Example 1:

Input:
n = 5
edges = [[0, 1], [0, 2], [0, 3], [1, 4]]

Output:
true

Example 2:

Input:
n = 5
edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]

Output:
false

Note:

    You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

Constraints:

    1 <= n <= 100
    0 <= edges.length <= n * (n - 1) / 2

Solution:
public class Solution {
    public bool ValidTree(int n, int[][] edges) {
        List<int>[] nodes = new List<int>[n];
        for(int i = 0; i < nodes.Length; i++) nodes[i] = new List<int>();
        foreach(var e in edges) {
            nodes[e[0]].Add(e[1]);
            nodes[e[1]].Add(e[0]);
        }

        HashSet<int> hs = new HashSet<int>();
        bool res = DFS(nodes, hs, -1, 0);
        return res && hs.Count == n;
    }

    public bool DFS(List<int>[] nodes, HashSet<int> visited, int parent, int node) {
        if (!visited.Add(node)) {
            return false;
        }

        foreach(var n in nodes[node]) {
            if (n != parent) {
                if (!DFS(nodes, visited, node, n)) {
                    return false;
                }
            }
        }

        return true;
    }
}
