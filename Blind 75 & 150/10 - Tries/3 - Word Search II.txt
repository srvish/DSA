Given a 2-D grid of characters board and a list of strings words, return all words that are present in the grid.

For a word to be present it must be possible to form the word with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.

Example 1:
Input:
board = [
  ["a","b","c","d"],
  ["s","a","a","t"],
  ["a","c","k","e"],
  ["a","c","d","n"]
],
words = ["bat","cat","back","backend","stack"]

Output: ["cat","back","backend"]

Example 2:
Input:
board = [
  ["x","o"],
  ["x","o"]
],
words = ["xoxo"]

Output: []

Constraints:

    1 <= board.length, board[i].length <= 12
    board[i] consists only of lowercase English letter.
    1 <= words.length <= 30,000
    1 <= words[i].length <= 10
    words[i] consists only of lowercase English letters.
    All strings within words are distinct.

Solution:
public class Solution {
    public List<string> FindWords(char[][] board, string[] words) {
        List<string> res = new List<string>();

        foreach(var word in words) {
            bool found = false;
            for(int i = 0; i < board.Length && !found; i++) {
                for (int j = 0; j < board[i].Length && !found; j++) {
                    if (word[0] == board[i][j]) {
                        if (Search(board, i, j, word, 0)) {
                            found = true;
                        }
                    }
                }
            }
            if (found) {
                res.Add(word);
            }
        }

        return res;
    }

    public bool Search(char[][] board, int i, int j, string word, int iw) {
        if (iw == word.Length) {
            return true;
        }

        if (i < 0 || j < 0 || i >= board.Length || j >= board[i].Length || word[iw] != board[i][j]) {
            return false;
        }

        board[i][j] = '.';
        bool l = Search(board, i - 1, j, word, iw + 1);
        bool t = Search(board, i, j - 1, word, iw + 1);
        bool r = Search(board, i + 1, j, word, iw + 1);
        bool d = Search(board, i, j + 1, word, iw + 1);
        board[i][j] = word[iw];
        return (l || t || r || d);
    }
}
