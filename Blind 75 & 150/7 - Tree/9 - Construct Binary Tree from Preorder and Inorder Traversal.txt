You are given two integer arrays preorder and inorder.

    preorder is the preorder traversal of a binary tree
    inorder is the inorder traversal of the same tree
    Both arrays are of the same size and consist of unique values.

Rebuild the binary tree from the preorder and inorder traversals and return its root.

Example 1:
Input: preorder = [1,2,3,4], inorder = [2,1,3,4]

Output: [1,2,3,null,null,null,4]

Example 2:

Input: preorder = [1], inorder = [1]

Output: [1]

Constraints:

    1 <= inorder.length <= 1000.
    inorder.length == preorder.length
    -1000 <= preorder[i], inorder[i] <= 1000

Solution:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

public class Solution {
    int index = 0;
    Dictionary<int,int> hash = new Dictionary<int, int>();
    public TreeNode BuildTree(int[] preorder, int[] inorder) {
        for(int i = 0; i < inorder.Length; i++) {
            hash[inorder[i]] = i;
        }
        return DFS(preorder, 0, preorder.Length - 1);
    }

    public TreeNode DFS(int[] inorder, int l , int r) {
        if (l > r) {
            return null;
        }
        int val = inorder[index++];
        int mid = hash[val];
        var root = new TreeNode(val);
        root.left = DFS(inorder, l, mid - 1);
        root.right = DFS(inorder, mid + 1, r);
        return root;
    }

}
